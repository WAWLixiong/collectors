#unix编程下的5中i/o模型(以下是发展的趋势)
# 阻塞式io
# 非阻塞式io
# io复用
# 信号驱动io 现阶段使用不多
# 异步io （posix的aio系列函数）

#阻塞不会消耗cpu
#但是非阻塞是io可能需要while循环来请求状态 ,时间与阻塞式io差不多
#非阻塞式的后续程序不依赖之前的代码，比较好

# 非阻塞式io
#数据从内核复制到用户空间
# 内存分为内核内存，与应用内存
# 网络返回的数据先返回到内核内存，之后在从内核存储copy到应用内存，这个过程需要耗费时间

#io复用(高并发技术使用这点)
# 内核内存收到数据后通知的机制
# io复用的三个技术，select，poll，epoll
# select方法也是一个阻塞的方法
# 如果没有一个sock或者文件句柄准备好，则会阻塞
# select可以监听多个socket，文件句柄
# io多路复用主要缺陷在于从内核空间复制数据到用户空间

# 异步io，（aio）
# 目前阶段使用不多
# 比io多路复用提升不明显
# aio是在操作系统准备好数据后，再给信号处理程序发送信息


# 重点学习io多路复用
# select poll epoll 都是io多路复用的机制，io多路复用就是通过一种机制，一个进程可以监听多个描述符
# 一旦某个描述符就绪，一般是读就绪或者写就绪，能够通知程序进行相应的操作，但select，poll，epoll本质上
# 都是同步io，因为他们都需要在读写事件就绪后自己负责读写(即从内核空间copy到用户空间,过程是阻塞的)，也就是说这个读写过程是阻塞的，而异步io则
# 无需自己负责读写，异步io的实现会负责把数据从内核拷贝到用户空间(自动从内核空间copy到用户空间)

# sock既可以往里边写数据，也可以从里边读取数据

# select
# select 最早的io多路复用技术，基本所有的操作系统都支持的技术
# select 函数监视的文件描述符分为3类，分别是writefds，readfds，和exceptfds，调用select函数会阻塞
# 直到有描述符就绪（有数据可读，可写，或者有except，或者超时, timeout指定超时时间，null则立即返回）,函数返回
# 当select函数返回后，可以遍历fdset，来找到就绪的描述符
# select基本在所有的平台支持，
# select的一个缺点是，单个进程能够监听的文件描述符的数量存在上限，linux一般是1024,可以通过修改宏定义甚至重新编译内核的方式
# 提升这一限制，但是也会造成效率的降低

# poll
# 不同于select的使用了三个位图来表示三个fdset的方式，poll使用一个pollfd的指针实现
# pollfd结构包含了要监视的event和发生的event，不再使用select "数-值"传递的方式，同时，pollfd没有最大数量的限制
# 但是数量过大后，也会造成性能降低，和select函数一样，poll返回后，需要轮训pollfd来获取就绪的描述符
# 缺点： 连接大量的描述符后，可能只有很少的准备就绪了，因此随着连接的描述符的增多，效率会降低

#epoll
#只在linux下支持，在windows下不支持
# 是之前的select和poll的增强版，epoll更加限制，没有描述符的限制
# epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，
# 这样在用户空间和内核空间的copy只需一次
# epoll的事件表的实现使用了一种红黑树，查询效率很高
# nginx 使用的就是epoll
# 不代表epoll就比select好
# 高并发的情况下，连接活跃度不是很高(网页)，epoll比select好
# 并发不是很高，连接很活跃的情况下(游戏)，select比epoll好























